package Chapter2.item7;


/** === 다 쓴 객체 참조를 해제하라 ===
 * - C 언어 같이 메모리를 직접 관리해야 하는 언어를 사용하다가 GC를 통해 메모리를 관리하는 JAVA를 사용하면 확실히 편리하다.
 * - 하지만 GC가 완벽한 것은 아니다.
 * - 중요한건 GC가 알아서 가져갈 수 있도록 더이상 쓰지 않는 객체에 마킹을 해야 한다는 것이다! (쓰레기를 종량제 봉투에 넣는 것)
 *
 * 1. Stack 구현 (StackMemory)
 *  - pop()에서 쓰지 않는 객체를 null 처리 하고 있다.
 *
 * 이 방법에 감명을 받아 사용하지 않는 모든 객체들을 null처리 해서는 안된다!!
 *  - 이 방법은 정말 예외적인 케이스에서만 사용해야 한다.
 *  - 가령 자기 메모리를 직접 관리하는 경우 (Stack)
 *      - Stack은 elements 배열로 저장소 풀을 만들어 원소들을 관리하기 때문에 null 처리를 해야 한다.
 *
 *
 * 그럼 어떻게 하냐? -> '그 참조를 담은 변수를 유효 범위(스코프)  밖으로 내보내는 것이 베스트!
 *  - 변수의 스코프를 최소화하면 문제가 없다. (로컬 변수)
 *  - 문제는 필드(전역)변수! size와 element 같은 경우
 *  - 그래서 null로 표기를 했던 것!
 *
 *
 * 캐시도 메모리 누수의 주범
 *  - 객체 참조를 캐시에 넣어두고 다 쓴 후 제거를 하지 않는 경우가 많다.
 *  - 이런 경우 WeakHashMap을 사용해 캐시를 만들면 다 쓴 엔트리는 즉시 제거가 된다. (Weak Reference를 고려)
 *
 * 콜백도 주의하라
 *  - 리스너와 콜백 사이에도 메모리 누수를 주의해야 한다.
 *  - 만약에 클라이언트 코드가 콜백을 등록할 수 있는 API를 만들고 콜백을 제거하는 방법을 알려주지 않으면, 계속 콜백이 쌓이게 된다.
 *  - 이 역시 WeakHashMap을 사용해서 해결할 수 있다.
 *
 * 정리
 *  - 메모리 누수는 정말 발견하기가 어렵다.
 *  -그래서 코드 인스택션이나 heap profiler 같은 디버깅 툴을 적극적으로 사용해 찾아야 한다.
 *  - 가장 좋은 방법은 공부해서 미연에 방지하는 것!
 *
 */
public class CloseTheInstance {
    public static void main(String[] args) {

    }
}
